package Analisis.HaskellArchivo;

import java_cup.runtime.Symbol;
import Extras.*;
import Analisis.*;
import Reportes.*;

parser code
{://Codigo visible

    public void syntax_error(Symbol s){
        TablaErrores.insertarError("Error Sintactico: "+s.value.toString()+" ",s.right,s.left);
        System.out.println(s.value.toString()+" Fila: " +s.right+", Columna: "+s.left);
    }

    public void unrecovered_syntax_error(Symbol s){        
        TablaErrores.insertarError("Error Sintactico: "+s.value.toString()+" ",s.right,s.left);
        System.out.println(s.value.toString()+" Fila: " +s.right+", Columna: "+s.left);
    }

:}

action code
{://Codigo de acciones
      
:}

terminal String mod, sqrt, pot, let, calcular, succ, decc, min, max, sum, product, revers, impr, par, asc, desc, length, si, entonces, fin, sino, caso, concatenacion, suma, resta, mult, div,eol,puntoycoma, acceso;
terminal String o, y, mayor, menor, mayorigual, menorigual, igualacion, distinto, igual, dolar, corchetea, corchetec, llavea, llavec, num, id, coma, cadena,caracter, parentesisa, parentesisc,dospuntos;
nonterminal Nodo S, HASKELL, LISTA, VALLISTA, EXP, LPARLISTA, PARLISTA, CALCULAR, SUCC, DECC, MIN, MAX, CONCAT, OTRA;
nonterminal Nodo LVOTRA, VOTRA, VALOTRA, ACCESO, OPLISTA, REVERS, IMPR, PAR, ASC, DESC, SUM, PRODUCT, DECFUN, PDECFUN,CUERPO;
nonterminal Nodo LLAMADO, LPFUN, SI, COND, REL, CASO, VCASO, LCASOS, CASOS, SENTENCIAS, VALFUN, LENGTH;
nonterminal String OPREL;

precedence left o;
precedence left y;
precedence left mayor, menor, mayorigual,menorigual, distinto, igualacion;
precedence left suma, resta;
precedence left mult, div, mod; 
precedence right pot,sqrt; 
precedence left concatenacion, acceso;

start with S;

S ::=   HASKELL:hk
    {:
        System.out.println("Archivo finalizado");
        SemanticoHaskell.raiz=hk;
        SemanticoHaskell.graficar();
    :};
HASKELL ::= HASKELL:hk DECFUN:decfun{:RESULT=Fabrica.insertarFuncion(hk,decfun);:}
                        | DECFUN:decfun {:RESULT = Fabrica.crearNodoLFunciones(decfun);:};

VALLISTA ::=   CONCAT
                          | cadena:cadena {:RESULT = Fabrica.crearNodoHoja(cadena);:}
                          | id:id{:RESULT = Fabrica.crearNodoHoja(id);:}
                          | LLAMADO
                          | OPLISTA
                          | corchetea LPARLISTA corchetec;

LPARLISTA ::= LPARLISTA coma PARLISTA
                          | PARLISTA;
PARLISTA ::= CALCULAR:calc{:RESULT = calc;:}
                         | caracter:caracter {:RESULT = Fabrica.crearNodoHoja(caracter);:}
                         | OTRA;
OTRA::= corchetea VALOTRA corchetec;

VALOTRA ::= cadena:cadena {:RESULT = Fabrica.crearNodoHoja(cadena);:} 
                        | LVOTRA;

LVOTRA ::= LVOTRA coma VOTRA
                    | VOTRA;
VOTRA ::= CALCULAR:calc{:RESULT = calc;:}
                  | caracter:caracter {:RESULT = Fabrica.crearNodoHoja(caracter);:} ;

CALCULAR ::= dolar calcular EXP:exp dolar{:RESULT=Fabrica.crearNodoEXP(exp);:};

SUCC ::=    dolar succ VALFUN dolar;

DECC ::=    dolar decc VALFUN dolar;

MIN ::=     dolar min VALLISTA dolar;

MAX ::=    dolar max VALLISTA dolar;

VALFUN ::= id:id{:RESULT = Fabrica.crearNodoHoja(id);:}
                    | CALCULAR:calc{:RESULT = calc;:}
                    | LLAMADO;

SUM ::= dolar sum VALLISTA dolar;
PRODUCT ::= dolar product VALLISTA dolar;
REVERS ::= dolar revers VALLISTA dolar;
IMPR::= dolar impr VALLISTA dolar;
PAR ::= dolar par VALLISTA dolar;
ASC ::= dolar asc VALLISTA dolar;
DESC ::= dolar desc VALLISTA dolar;
LENGTH ::= dolar length VALLISTA dolar;

CONCAT ::= VALLISTA concatenacion VALLISTA;

ACCESO ::= VALLISTA acceso EXP;

OPLISTA ::= REVERS
                     | IMPR
                     | PAR
                     | ASC
                     | DESC;

DECFUN ::= id:id PDECFUN:lpar igual CUERPO:cuerpo fin {:RESULT = Fabrica.crearNodoFuncion(id,lpar,cuerpo);:}
                       | eol{:RESULT=null;:};

PDECFUN ::= PDECFUN:lpar coma id:id
                        {:
                            Nodo par = Fabrica.crearNodoHoja(id);
                            RESULT=Fabrica.insertarPar(lpar,par);
                        :}
                        |id:id
                        {:
                            Nodo par = Fabrica.crearNodoHoja(id);
                            RESULT=Fabrica.crearNodoLPAR(par);
                        :}
                        |{:RESULT=Fabrica.crearNodoLPAR(null);:};
CUERPO ::= CUERPO:cuerpo SENTENCIAS:sent {:RESULT = Fabrica.insertarSentencia(cuerpo,sent);:}
                     | SENTENCIAS:sent {:RESULT=Fabrica.crearNodoCuerpo(sent);:};

SENTENCIAS ::= LISTA:list {:RESULT = list;System.out.println("lista");:}
                             | CALCULAR:calc{:RESULT = calc;:}
                             | SUCC
                             | DECC
                             | MIN
                             | MAX
                             | CONCAT
                             | ACCESO
                             | SUM
                             | PRODUCT
                             | REVERS
                             | IMPR
                             | PAR
                             | ASC  
                             | DESC
                             | LENGTH
                             | LLAMADO
                             | SI
                             | CASO
                             | eol{:RESULT = null;System.out.println("eol");:};

LISTA ::=  let id:id igual VALLISTA:val{:RESULT = Fabrica.crearNodoLista(id,val);:};

LLAMADO ::= dolar id llavea LPFUN llavec dolar;

LPFUN ::= LPFUN coma VALFUN
                        | VALFUN
                        | {::};

EXP ::= EXP:op1 suma EXP:op2{:RESULT=Fabrica.crearNodoOperacion(Constante.suma,op1,op2);:}
             | EXP:op1 resta EXP:op2 {:RESULT=Fabrica.crearNodoOperacion(Constante.resta,op1,op2);:}
             | EXP:op1 mult EXP:op2 {:RESULT=Fabrica.crearNodoOperacion(Constante.mult,op1,op2);:}             
             | EXP:op1 div EXP:op2 {:RESULT=Fabrica.crearNodoOperacion(Constante.div,op1,op2);:}             
             | EXP:op1 mod EXP:op2{:RESULT=Fabrica.crearNodoOperacion(Constante.mod,op1,op2);:}
             | EXP:op1 sqrt EXP:op2 {:RESULT=Fabrica.crearNodoOperacion(Constante.sqrt,op1,op2);:}
             | EXP:op1 pot EXP:op2 {:RESULT=Fabrica.crearNodoOperacion(Constante.pot,op1,op2);:}             
             | resta EXP:op1 {:RESULT=Fabrica.crearNodoOperacion(Constante.resta,op1);:}             
             | parentesisa EXP:exp parentesisc {:RESULT=exp;:}
             | CALCULAR:calc{:RESULT = calc;:}
             | SUCC
             | DECC
             | MIN
             | MAX
             | CONCAT
             | ACCESO   
             | SUM
             | PRODUCT
             | LENGTH
             | LLAMADO             
             | num:num {:RESULT = Fabrica.crearNodoHoja(num);:}
             | caracter:caracter {:RESULT = Fabrica.crearNodoHoja(caracter);:}
             | id:id{:RESULT = Fabrica.crearNodoHoja(id);:};

SI ::= si COND entonces CUERPO sino CUERPO fin;

COND ::= REL:op1 o REL:op2{:RESULT=Fabrica.crearNodoOperacion(Constante.o,op1,op2);:}
                | REL:op1 y REL:op2 {:RESULT=Fabrica.crearNodoOperacion(Constante.y,op1,op2);:}
                | REL:rel {:RESULT=rel;:};

REL ::= VALFUN:op1 OPREL:operador VALFUN:op2  {:RESULT=Fabrica.crearNodoOperacion(operador,op1,op2);:};

OPREL ::= mayor {:RESULT = Constante.mayor;:}
                    | menor{:RESULT = Constante.menor;:}
                    | mayorigual{:RESULT = Constante.mayorigual;:}
                    | menorigual{:RESULT = Constante.menorigual;:}
                    | igualacion{:RESULT = Constante.igualacion;:}
                    | distinto{:RESULT = Constante.distinto;:};

CASO ::= caso VALFUN eol LCASOS fin;

VCASO ::= num:num {:RESULT = Fabrica.crearNodoHoja(num);:}
                    | caracter:caracter {:RESULT = Fabrica.crearNodoHoja(caracter);:};

LCASOS ::= LCASOS CASOS
                    | CASOS;

CASOS ::= VCASO dospuntos CUERPO puntoycoma eol;














